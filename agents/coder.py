import re
from utils.llm_client import LLMClient
import textwrap

class CoderAgent:

  def __init__(self, llm_client: LLMClient):
    self.llm = llm_client

  def code(self, prompt: str, plan: str, current_code: str, feedback: str) -> str:
    """Generate or fix code based on plan and test feedback."""
    signature = self._extract_signature_from_plan(plan)

    if current_code and feedback:
        full_prompt = self._fix_prompt_template(
            prompt=prompt,
            plan=plan,
            current_code=current_code,
            feedback=feedback,
            signature=signature
        )
        temp = 0.4
    else:
        full_prompt = self._generate_prompt_template(
            prompt=prompt,
            plan=plan,
            signature=signature
        )
        temp = 0.2
    
    response = self.llm.generate_response(
       full_prompt,
       temperature=temp,
        max_new_tokens=1024
    )
    
    if isinstance(response, tuple):
        response = response[0]

            # DEBUG TEMPORANEO
    print("\n===== RAW LLM OUTPUT =====\n")
    print(response)
    print("\n==========================\n")

    return self._extract_clean_code(response)

  def _extract_signature_from_plan(self, plan: str) -> str:
    match = re.search(r"SIGNATURE:\s*(def\s+\w+\s*\(.*?\))", plan)
    if match:
        return match.group(1).strip()
    return "def function(...)"



  def _generate_prompt_template(self, *, prompt: str, plan: str, signature: str) -> str:
    return f"""### ROLE: EXPERT PYTHON IMPLEMENTER
        You are the "Coding Component" in a Multi-Agent system. 
        Your specific job is to translate a logic plan into high-performance, bug-free Python code.

        ### TASK SPECIFICATION
        Write a complete, self-contained Python solution for the following problem.
        {prompt}

        ### THE PLAN TO FOLLOW
        This plan was generated by the Planner Agent. You must implement it strictly:
        {plan}

        ### COMPILER & STYLE REQUIREMENTS (STRICT)
        1. **Entry Point**: Use exactly this function signature: {signature}
        2. **Dependencies**: Include ALL necessary standard library imports at the top.
        3. **Purity**: Output ONLY valid Python code. No markdown, no comments, no explanations.
        4. **Logic Integrity**: Ensure all edge cases (empty inputs, large values) are handled according to the plan.
        
        ### ARCHITECTURAL GOALS:
        1. **Efficiency**: Use optimal algorithms and data structures. Minimize time and space complexity.
        2. **Maintainability**: Ensure clean, readable logic.
        
        ### OUTPUT GENERATION
        ```python
        """


  def _fix_prompt_template(self, *, prompt: str, plan: str, current_code: str, feedback: str, signature: str) -> str:
    return f"""### SYSTEM INSTRUCTION
        You are a Python Code Generation Engine.
        Your output is piped directly into a Python compiler. Any text that is not valid Python code will cause a system crash.
        You are fixing a previous implementation based on Reviewer feedback.

        ### MANDATORY TASK
        1. Use exactly this function signature: {signature}
        2. Incorporate the Reviewer Fixes to repair the Broken Code.
        3. Follow the original Plan only where it does not conflict with the Fixes.

        ### ARCHITECTURAL GOALS:
        1. **Efficiency**: Use optimal algorithms and data structures. Minimize time and space complexity.
        2. **Maintainability**: Ensure clean, readable logic.

        ### REVIEWER FIXES (PRIORITY)
        {feedback}

        ### ORIGINAL PLAN
        {plan}

        ### BROKEN CODE TO REPAIR
        {current_code}

        ### OUTPUT REQUIREMENTS
        - Include ALL necessary imports (e.g., from typing import List).
        - Output ONLY valid Python code.
        - No markdown blocks (no ```python), no explanations, no comments.
        - Start directly with the code.

        ### CORRECTED CODE:
        ```python
        """


  def _extract_clean_code(self, response: str) -> str:
    # Rimuove tutti i blocchi markdown lasciando solo il contenuto testuale
    response = re.sub(r"```python", "", response, flags=re.IGNORECASE)
    response = re.sub(r"```", "", response)
    
    lines = response.splitlines()
    code_lines = []
    
    # Identifichiamo parole chiave che segnalano l'inizio del codice reale
    code_keywords = ("import ", "from ", "def ", "class ")
    
    in_code_block = False
    for line in lines:
        stripped = line.strip()
        
        # Inizia a raccogliere dalla prima riga di codice (import o def)
        if any(stripped.startswith(k) for k in code_keywords):
            in_code_block = True
            
        if in_code_block:
            # Continua a raccogliere finch√© le righe sono coerenti con il codice
            # (indentate, vuote, o nuove definizioni/import)
            if line.startswith(" ") or line.startswith("\t") or stripped == "" or any(stripped.startswith(k) for k in code_keywords):
                code_lines.append(line)
            else:
                break
            
    raw_code = "\n".join(code_lines)
    return textwrap.dedent(raw_code).strip()  

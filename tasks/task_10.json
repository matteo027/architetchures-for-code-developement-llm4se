{ 
  "task_id": "Task10", 
  "prompt": "from typing import List, Dict, Tuple\n\ndef solve_graph_cycle_removal_and_max_distance(file_content: str) -> Tuple[Dict, Dict]:\n    \"\"\"\n    Reads a weighted, directed, and connected graph from a string ('file_content'),\n    transforms it into a Directed Acyclic Graph (DAG) by removing the maximum\n    weight Cycle-Breaking Edge Set (of minimum cardinality), and then calculates the maximum\n    distances (longest paths) from every source node to all other reachable nodes in the resulting DAG.\n\n    The input string format is:\n    1. Integer N (number of vertices) on the first line.\n    2. N lines, each with a unique alphanumeric node ID (up to 30 chars).\n    3. Indefinite lines of triplets: <id_1> <id_2> <weight> (non-negative integer).\n\n    The overall process must implement:\n    1. **Minimum Feedback Edge Set (FES) Candidates:** Identify all sets of edges with minimum cardinality\n       whose removal makes the graph a DAG.\n    2. **DAG Construction:** Select and remove the FES candidate with the **maximum total weight**\n       (sum of weights of edges in the set).\n    3. **Maximum Distances:** In the constructed DAG, calculate the maximum distance (longest path)\n       from every source node to all other reachable nodes (using Topological Sort).\n\n    Returns:\n    - A dictionary representing the final DAG's adjacency list (Node ID -> list of (neighbor_id, weight)).\n    - A dictionary of maximum distances: {source_node_id: {target_node_id: max_distance}}.\n    \"\"\"\n    pass",
  "entry_point": "solve_graph_cycle_removal_and_max_distance",
  "canonical_solution": "",
  "test": "",
  {
  "prompt": "from typing import List, Dict, Tuple \\n\\n def solve_graph_cycle_removal_and_max_distance(file_content: str) -> Tuple[Dict[str, Dict[str, int]], Dict[str, Dict[str, int]]]:\\n    \"\"\"\\n    [descrizione]\\n    \"\"\"\\n    pass"
}

}

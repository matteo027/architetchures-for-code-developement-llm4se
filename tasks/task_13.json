{
  "task_id": "CodeNet/AIZU/GRL_6_A",
  "prompt": "def maximum_flow(n, edges):\n    \"\"\"\n    Maximum Flow Problem\n\n    A flow network is a directed graph which has a source (vertex 0) and a sink\n    (vertex n-1). In a flow network, each edge (u, v) has a capacity c(u, v).\n    Each edge receives a flow, but the amount of flow on the edge cannot exceed\n    the corresponding capacity.\n\n    Find the maximum flow from the source (vertex 0) to the sink (vertex n-1).\n\n    This problem requires implementing a maximum flow algorithm such as:\n    - Ford-Fulkerson with BFS (Edmonds-Karp algorithm)\n    - Dinic's algorithm\n    - Push-relabel algorithm\n\n    The algorithm must:\n    1. Build a residual graph from the input edges\n    2. Repeatedly find augmenting paths from source to sink\n    3. Update the residual capacities along the path\n    4. Sum up all the flow pushed through augmenting paths\n\n    Args:\n        n: int - number of vertices (vertices numbered 0 to n-1)\n                 source = 0, sink = n-1\n        edges: list of tuples (u, v, c) - directed edges where:\n               u = source vertex of edge\n               v = destination vertex of edge  \n               c = capacity of edge (max flow allowed through this edge)\n\n    Returns:\n        int - the maximum flow from vertex 0 to vertex n-1\n\n    Constraints:\n        - 2 <= n <= 100\n        - 1 <= |edges| <= 1000\n        - 0 <= capacity <= 10000\n\n    Example 1:\n        Input:\n            n = 4\n            edges = [(0,1,2), (0,2,1), (1,2,1), (1,3,1), (2,3,2)]\n\n        Graph visualization:\n                 2\n            0 -------> 1\n            |          |  \\\n          1 |        1 |   \\ 1\n            v          v    v\n            2 -------> 3 (sink)\n                 2\n\n        Output: 3\n\n        Explanation:\n        - Path 0->1->3 can carry flow of 1\n        - Path 0->2->3 can carry flow of 1  \n        - Path 0->1->2->3 can carry flow of 1\n        - Total maximum flow = 3\n\n    Example 2:\n        Input:\n            n = 2\n            edges = [(0,1,5)]\n        Output: 5 (direct edge from source to sink)\n\n    Example 3:\n        Input:\n            n = 5\n            edges = [(0,1,10), (0,2,10), (1,3,4), (1,4,8), (2,4,9), (3,4,10)]\n        Output: 19\n\n    Note: This is a classic graph theory problem that requires understanding of:\n    - Residual graphs and reverse edges\n    - Augmenting paths\n    - The max-flow min-cut theorem\n    \"\"\"\n",
  "entry_point": "maximum_flow",
  "canonical_solution": "    from collections import defaultdict, deque\n    \n    # Build adjacency list with capacities\n    # graph[u] = list of [v, capacity, index_of_reverse_edge]\n    graph = defaultdict(list)\n    \n    def add_edge(u, v, cap):\n        graph[u].append([v, cap, len(graph[v])])\n        graph[v].append([u, 0, len(graph[u]) - 1])  # reverse edge with 0 capacity\n    \n    for u, v, c in edges:\n        add_edge(u, v, c)\n    \n    source, sink = 0, n - 1\n    \n    def bfs():\n        \"\"\"Find augmenting path using BFS, return parent map or None\"\"\"\n        parent = {source: None}\n        visited = {source}\n        queue = deque([source])\n        \n        while queue:\n            u = queue.popleft()\n            for i, (v, cap, _) in enumerate(graph[u]):\n                if v not in visited and cap > 0:\n                    visited.add(v)\n                    parent[v] = (u, i)\n                    if v == sink:\n                        return parent\n                    queue.append(v)\n        return None\n    \n    max_flow = 0\n    \n    while True:\n        parent = bfs()\n        if parent is None:\n            break\n        \n        # Find minimum capacity along the path\n        path_flow = float('inf')\n        v = sink\n        while parent[v] is not None:\n            u, edge_idx = parent[v]\n            path_flow = min(path_flow, graph[u][edge_idx][1])\n            v = u\n        \n        # Update capacities along the path\n        v = sink\n        while parent[v] is not None:\n            u, edge_idx = parent[v]\n            graph[u][edge_idx][1] -= path_flow\n            rev_idx = graph[u][edge_idx][2]\n            graph[v][rev_idx][1] += path_flow\n            v = u\n        \n        max_flow += path_flow\n    \n    return max_flow\n",
  "test": "\n\nMETADATA = {\n    'author': 'aizu',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    # Official AIZU sample\n    assert candidate(4, [(0,1,2), (0,2,1), (1,2,1), (1,3,1), (2,3,2)]) == 3\n    \n    # Simple direct edge\n    assert candidate(2, [(0,1,5)]) == 5\n    \n    # Two parallel paths\n    assert candidate(2, [(0,1,3), (0,1,4)]) == 7\n    \n    # Linear path\n    assert candidate(4, [(0,1,10), (1,2,5), (2,3,10)]) == 5\n    \n    # Bottleneck in the middle\n    assert candidate(3, [(0,1,100), (1,2,1)]) == 1\n    \n    # Diamond graph\n    assert candidate(4, [(0,1,3), (0,2,3), (1,3,2), (2,3,2)]) == 4\n    \n    # More complex network\n    assert candidate(5, [(0,1,10), (0,2,10), (1,3,4), (1,4,8), (2,4,9), (3,4,10)]) == 19\n    \n    # Graph with cycle\n    assert candidate(4, [(0,1,5), (1,2,3), (2,0,2), (1,3,4), (2,3,3)]) == 5\n    \n    # Multiple edges same direction\n    assert candidate(3, [(0,1,2), (0,1,3), (1,2,4)]) == 4\n    \n    # Larger network\n    edges = [\n        (0,1,16), (0,2,13),\n        (1,2,10), (1,3,12),\n        (2,1,4), (2,4,14),\n        (3,2,9), (3,5,20),\n        (4,3,7), (4,5,4)\n    ]\n    assert candidate(6, edges) == 23\n\n"
}
